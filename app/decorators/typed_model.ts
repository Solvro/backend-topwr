import vine from "@vinejs/vine";
import { SchemaTypes } from "@vinejs/vine/types";
import assert from "node:assert";

import { column, manyToMany } from "@adonisjs/lucid/orm";
import { ColumnOptions, LucidModel } from "@adonisjs/lucid/types/model";
import {
  ManyToMany,
  ManyToManyRelationOptions,
} from "@adonisjs/lucid/types/relations";

type SharedColumnTypes = "string" | "number" | "boolean";
export type ColumnType = SharedColumnTypes | "enum" | "DateTime";
type DecoratorTypes = SharedColumnTypes | "integer" | "uuid";

export interface ColumnDef extends ColumnOptions {
  meta?: {
    declaredType?: ColumnType;
    allowedValues?: string[];
    validator?: SchemaTypes;
    optional?: boolean;
    autoGenerated?: boolean;
  };
}

type SharedTypedColumnOptions = Partial<ColumnDef> & {
  /**
   * a raw vinejs "validator" (not vine.compile()d)
   */
  validator?: SchemaTypes;
  /**
   * false by default - if true, null/unefined values will be allowed in CRUD endpoints
   */
  optional?: boolean;
  /**
   * defaults to true if primaryKey or autoCreate = true, false otherwise
   * if true, this field will not be allowed in CRUD endpoints
   */
  autoGenerated?: boolean;
};

type MainTypedColumnOptions = SharedTypedColumnOptions &
  (
    | {
        type: DecoratorTypes;
        /**
         * a raw vinejs "validator" (not vine.compile()d)
         */
        validator?: SchemaTypes;
      }
    | {
        type: Record<string, string>; // enum
        /**
         * enums are not allowed to have custom validators
         */
        validator?: undefined;
      }
  );

type DateTypedColumnOptions = SharedTypedColumnOptions & {
  // lucid column.date() options
  autoCreate?: boolean;
  autoUpdate?: boolean;
};

type RelationColumnDef = {
  validator: SchemaTypes;
  optional: boolean;
  autoGenerated: boolean;
} & (
  | { type: Exclude<ColumnType, "enum"> }
  | { type: "enum"; allowedValues: string[] }
);

type TypedManyToManyOptions<Related extends LucidModel> = Omit<
  ManyToManyRelationOptions<ManyToMany<Related>>,
  "pivotColumns"
> & {
  pivotColumns: Record<
    string,
    | {
        type: DecoratorTypes;
        validator?: SchemaTypes;
        optional?: boolean;
        autoGenerated?: boolean;
      }
    | {
        type: Record<string, string>;
        validator?: undefined;
        optional?: boolean;
        autoGenerated?: boolean;
      }
  >;
  meta?: {
    declaredColumnTypes: Record<string, RelationColumnDef>;
  };
};

function decoratorTypeToValidatorAndType(
  type: DecoratorTypes | Record<string, string>,
  optional: boolean | undefined,
): { validator: SchemaTypes; declaredType: ColumnType } {
  if (typeof type === "string") {
    const declaredType =
      type === "integer" ? "number" : type === "uuid" ? "string" : type;
    let validator;
    switch (type) {
      case "string": {
        if (optional === true) {
          validator = vine.string().minLength(1).optional();
        } else {
          validator = vine.string().minLength(1);
        }
        break;
      }
      case "number": {
        if (optional === true) {
          validator = vine.number().optional();
        } else {
          validator = vine.number();
        }
        break;
      }
      case "boolean": {
        if (optional === true) {
          validator = vine.boolean().optional();
        } else {
          validator = vine.boolean();
        }
        break;
      }
      case "integer": {
        if (optional === true) {
          validator = vine.number().withoutDecimals().optional();
        } else {
          validator = vine.number().withoutDecimals();
        }
        break;
      }
      case "uuid": {
        if (optional === true) {
          validator = vine
            .string()
            .uuid({ version: [4] })
            .optional();
        } else {
          validator = vine.string().uuid({ version: [4] });
        }
        break;
      }
    }
    return {
      declaredType,
      validator,
    };
  } else {
    let validator;
    if (optional === true) {
      validator = vine.enum(type).optional();
    } else {
      validator = vine.enum(type);
    }
    return {
      declaredType: "enum",
      validator,
    };
  }
}

/**
 * Property decorator for injecting custom column types into a Lucid model.
 * ---------------------------------------------------------------------
 *
 * The `typedColumn` decorator allows you to specify and inject custom types for model columns by
 * adding type information to the `meta` property of each column definition.
 *
 * `typedColumn` is a replacement for lucid's `column` decorator.
 *
 * **Support for Enums**
 * - Enums are supported, provide an enum object as a value instead of string literal of a type
 * - such provided enum injects specified type and allowed values
 *
 */
export function typedColumn(options: MainTypedColumnOptions) {
  options.meta ??= {};
  options.meta.optional = options.optional ?? false;
  const { declaredType, validator } = decoratorTypeToValidatorAndType(
    options.type,
    options.optional,
  );
  options.meta.declaredType = declaredType;
  options.meta.validator = options.validator ?? validator;
  if (typeof options.type === "object") {
    options.meta.allowedValues = Object.keys(options.type);
  }
  options.meta.autoGenerated =
    options.autoGenerated ?? options.isPrimary ?? false;
  const finalOptions: Partial<MainTypedColumnOptions & ColumnDef> = {
    ...options,
  };
  delete finalOptions.type;
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  return column(finalOptions);
}

function dateTypedColumn(
  options: DateTypedColumnOptions,
  variant: "dateTime" | "date",
) {
  options.meta ??= {};
  options.meta.declaredType = "DateTime";
  options.meta.optional = options.optional ?? false;
  if (options.validator !== undefined) {
    options.meta.validator = options.validator;
  } else if (options.meta.optional === true) {
    options.meta.validator = vine.date().optional();
  } else {
    options.meta.validator = vine.date();
  }
  options.meta.autoGenerated =
    options.autoGenerated ??
    ((options.isPrimary ?? false) || (options.autoCreate ?? false));
  const finalOptions: Partial<DateTypedColumnOptions & ColumnDef> = {
    ...options,
  };
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  if (variant === "date") {
    return column.date(finalOptions);
  }
  return column.dateTime(finalOptions);
}

typedColumn.date = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "date");
typedColumn.dateTime = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "dateTime");

export function typedManyToMany<Related extends LucidModel>(
  model: () => Related,
  options: TypedManyToManyOptions<Related>,
) {
  options.meta ??= { declaredColumnTypes: {} };
  options.meta.declaredColumnTypes = Object.fromEntries(
    Object.entries(options.pivotColumns).map(([name, opts]) => {
      const { declaredType, validator } = decoratorTypeToValidatorAndType(
        opts.type,
        opts.optional,
      );
      if (declaredType === "enum") {
        assert(typeof opts.type === "object");
        return [
          name,
          {
            type: declaredType,
            allowedValues: Object.keys(opts.type),
            validator: opts.validator,
            optional: opts.optional ?? false,
            autoGenerated: opts.autoGenerated ?? false,
          },
        ];
      }
      return [
        name,
        {
          type: declaredType,
          validator: opts.validator ?? validator,
          optional: opts.optional ?? false,
          autoGenerated: opts.autoGenerated ?? false,
        },
      ];
    }),
  ) as Record<string, RelationColumnDef>;
  if (options.pivotTimestamps === true) {
    options.meta.declaredColumnTypes.createdAt = {
      type: "DateTime",
      validator: vine.date(),
      optional: false,
      autoGenerated: true,
    };
    options.meta.declaredColumnTypes.updatedAt = {
      type: "DateTime",
      validator: vine.date(),
      optional: false,
      autoGenerated: true,
    };
  }

  const col: ManyToManyRelationOptions<ManyToMany<Related>> = {
    ...options,
    pivotColumns: Object.keys(options.pivotColumns),
  };
  return manyToMany(model, col);
}
