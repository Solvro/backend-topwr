import vine from "@vinejs/vine";
import { SchemaTypes } from "@vinejs/vine/types";

import { column } from "@adonisjs/lucid/orm";
import { ColumnOptions } from "@adonisjs/lucid/types/model";

type SharedColumnTypes = "string" | "number" | "boolean";
export type ColumnType = SharedColumnTypes | "enum" | "DateTime";

export interface ColumnDef extends ColumnOptions {
  meta?: {
    declaredType?: ColumnType;
    allowedValues?: string[];
    validator?: SchemaTypes;
    optional?: boolean;
    autoGenerated?: boolean;
  };
}

type SharedTypedColumnOptions = Partial<ColumnDef> & {
  /**
   * a raw vinejs "validator" (not vine.compile()d)
   */
  validator?: SchemaTypes;
  /**
   * false by default - if true, null/unefined values will be allowed in CRUD endpoints
   */
  optional?: boolean;
  /**
   * defaults to true if primaryKey or autoCreate = true, false otherwise
   * if true, this field will not be allowed in CRUD endpoints
   */
  autoGenerated?: boolean;
};

type MainTypedColumnOptions = SharedTypedColumnOptions &
  (
    | {
        type: SharedColumnTypes | "integer" | "uuid";
        /**
         * a raw vinejs "validator" (not vine.compile()d)
         */
        validator?: SchemaTypes;
      }
    | {
        type: Record<string, string>; // enum
        /**
         * enums are not allowed to have custom validators
         */
        validator?: undefined;
      }
  );

type DateTypedColumnOptions = SharedTypedColumnOptions & {
  // lucid column.date() options
  autoCreate?: boolean;
  autoUpdate?: boolean;
};

/**
 * Property decorator for injecting custom column types into a Lucid model.
 * ---------------------------------------------------------------------
 *
 * The `typedColumn` decorator allows you to specify and inject custom types for model columns by
 * adding type information to the `meta` property of each column definition.
 *
 * `typedColumn` is a replacement for lucid's `column` decorator.
 *
 * **Support for Enums**
 * - Enums are supported, provide an enum object as a value instead of string literal of a type
 * - such provided enum injects specified type and allowed values
 *
 */
export function typedColumn(opts: MainTypedColumnOptions) {
  opts.meta ??= {};
  opts.meta.optional = opts.optional ?? false;
  if (typeof opts.type === "string") {
    opts.meta.declaredType =
      opts.type === "integer"
        ? "number"
        : opts.type === "uuid"
          ? "string"
          : opts.type;
    if (opts.validator !== undefined) {
      opts.meta.validator = opts.validator;
    } else {
      switch (opts.type) {
        case "string": {
          if (opts.meta.optional === true) {
            opts.meta.validator = vine.string().minLength(1).optional();
          } else {
            opts.meta.validator = vine.string().minLength(1);
          }
          break;
        }
        case "number": {
          if (opts.meta.optional === true) {
            opts.meta.validator = vine.number().optional();
          } else {
            opts.meta.validator = vine.number();
          }
          break;
        }
        case "boolean": {
          if (opts.meta.optional === true) {
            opts.meta.validator = vine.boolean().optional();
          } else {
            opts.meta.validator = vine.boolean();
          }
          break;
        }
        case "integer": {
          if (opts.meta.optional === true) {
            opts.meta.validator = vine.number().withoutDecimals().optional();
          } else {
            opts.meta.validator = vine.number().withoutDecimals();
          }
          break;
        }
        case "uuid": {
          if (opts.meta.optional === true) {
            opts.meta.validator = vine
              .string()
              .uuid({ version: [4] })
              .optional();
          } else {
            opts.meta.validator = vine.string().uuid({ version: [4] });
          }
          break;
        }
      }
    }
  } else {
    opts.meta.declaredType = "enum";
    opts.meta.allowedValues = Object.values(opts.type);
    if (opts.meta.optional === true) {
      opts.meta.validator = vine.enum(opts.type).optional();
    } else {
      opts.meta.validator = vine.enum(opts.type);
    }
  }
  opts.meta.autoGenerated = opts.autoGenerated ?? opts.isPrimary ?? false;
  const finalopts: Partial<MainTypedColumnOptions & ColumnDef> = {
    ...opts,
  };
  delete finalopts.type;
  delete finalopts.validator;
  delete finalopts.optional;
  delete finalopts.autoGenerated;
  return column(finalopts);
}

function dateTypedColumn(
  opts: DateTypedColumnOptions,
  variant: "dateTime" | "date",
) {
  opts.meta ??= {};
  opts.meta.declaredType = "DateTime";
  opts.meta.optional = opts.optional ?? false;
  if (opts.validator !== undefined) {
    opts.meta.validator = opts.validator;
  } else if (opts.meta.optional === true) {
    opts.meta.validator = vine.date().optional();
  } else {
    opts.meta.validator = vine.date();
  }
  opts.meta.autoGenerated =
    opts.autoGenerated ??
    ((opts.isPrimary ?? false) || (opts.autoCreate ?? false));
  const finalOptions: Partial<DateTypedColumnOptions & ColumnDef> = {
    ...opts,
  };
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  if (variant === "date") {
    return column.date(finalOptions);
  }
  return column.dateTime(finalOptions);
}

typedColumn.date = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "date");
typedColumn.dateTime = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "dateTime");
