import vine from "@vinejs/vine";
import { SchemaTypes } from "@vinejs/vine/types";

import { column } from "@adonisjs/lucid/orm";
import { ColumnOptions } from "@adonisjs/lucid/types/model";

type SharedColumnTypes = "string" | "number" | "boolean";
export type ColumnType = SharedColumnTypes | "enum" | "DateTime";

export interface ColumnDef extends ColumnOptions {
  meta?: {
    declaredType?: ColumnType;
    allowedValues?: string[];
    validator?: SchemaTypes;
    optional?: boolean;
    autoGenerated?: boolean;
  };
}

type SharedTypedColumnOptions = Partial<ColumnDef> & {
  /**
   * a raw vinejs "validator" (not vine.compile()d)
   */
  validator?: SchemaTypes;
  /**
   * false by default - if true, null/unefined values will be allowed in CRUD endpoints
   */
  optional?: boolean;
  /**
   * defaults to true if primaryKey or autoCreate = true, false otherwise
   * if true, this field will not be allowed in CRUD endpoints
   */
  autoGenerated?: boolean;
};

type MainTypedColumnOptions = (
  | {
      type: SharedColumnTypes | "integer" | "uuid";
      /**
       * a raw vinejs "validator" (not vine.compile()d)
       */
      validator?: SchemaTypes;
    }
  | {
      type: Record<string, string>; // enum
      /**
       * enums are not allowed to have custom validators
       */
      validator?: undefined;
    }
) &
  SharedTypedColumnOptions;

type DateTypedColumnOptions = {
  // lucid column.date() options
  autoCreate?: boolean;
  autoUpdate?: boolean;
} & SharedTypedColumnOptions;

/**
 * Property decorator for injecting custom column types into a Lucid model.
 * ---------------------------------------------------------------------
 *
 * The `typedColumn` decorator allows you to specify and inject custom types for model columns by
 * adding type information to the `meta` property of each column definition.
 *
 * `typedColumn` is a replacement for lucid's `column` decorator.
 *
 * **Support for Enums**
 * - Enums are supported, provide an enum object as a value instead of string literal of a type
 * - such provided enum injects specified type and allowed values
 *
 */
export function typedColumn(opts: MainTypedColumnOptions) {
  const options = opts as MainTypedColumnOptions & Partial<ColumnDef>;
  options.meta ??= {};
  options.meta.optional = options.optional ?? false;
  if (typeof options.type === "string") {
    options.meta.declaredType =
      options.type === "integer"
        ? "number"
        : options.type === "uuid"
          ? "string"
          : options.type;
    if (options.validator !== undefined) {
      options.meta.validator = options.validator;
    } else {
      switch (options.type) {
        case "string": {
          if (options.meta.optional === true) {
            options.validator = vine.string().minLength(1).optional();
          } else {
            options.validator = vine.string().minLength(1);
          }
          break;
        }
        case "number": {
          if (options.meta.optional === true) {
            options.validator = vine.number().optional();
          } else {
            options.validator = vine.number();
          }
          break;
        }
        case "boolean": {
          if (options.meta.optional === true) {
            options.validator = vine.boolean().optional();
          } else {
            options.validator = vine.boolean();
          }
          break;
        }
        case "integer": {
          if (options.meta.optional === true) {
            options.validator = vine.number().withoutDecimals().optional();
          } else {
            options.validator = vine.number().withoutDecimals();
          }
          break;
        }
        case "uuid": {
          if (options.meta.optional === true) {
            options.validator = vine
              .string()
              .uuid({ version: [4] })
              .optional();
          } else {
            options.validator = vine.string().uuid({ version: [4] });
          }
          break;
        }
      }
    }
  } else {
    options.meta.declaredType = "enum";
    options.meta.allowedValues = Object.values(options.type);
    if (options.meta.optional === true) {
      options.meta.validator = vine.enum(options.type).optional();
    } else {
      options.meta.validator = vine.enum(options.type);
    }
  }
  options.meta.autoGenerated =
    options.autoGenerated ?? options.isPrimary ?? false;
  const finalOptions: Partial<MainTypedColumnOptions & ColumnDef> = {
    ...options,
  };
  delete finalOptions.type;
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  return column(finalOptions);
}

function dateTypedColumn(
  opts: DateTypedColumnOptions,
  variant: "dateTime" | "date",
) {
  const options = opts as DateTypedColumnOptions & Partial<ColumnDef>;
  options.meta ??= {};
  options.meta.declaredType = "DateTime";
  options.meta.optional = options.optional ?? false;
  if (options.validator !== undefined) {
    options.meta.validator = options.validator;
  } else if (options.meta.optional === true) {
    options.meta.validator = vine.date().optional();
  } else {
    options.meta.validator = vine.date();
  }
  options.meta.autoGenerated =
    options.autoGenerated ??
    ((options.isPrimary ?? false) || (options.autoCreate ?? false));
  const finalOptions: Partial<DateTypedColumnOptions & ColumnDef> = {
    ...options,
  };
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  if (variant === "date") {
    return column.date(finalOptions);
  }
  return column.dateTime(finalOptions);
}

typedColumn.date = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "date");
typedColumn.dateTime = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "dateTime");
