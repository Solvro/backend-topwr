import vine from "@vinejs/vine";
import { SchemaTypes } from "@vinejs/vine/types";
import assert from "node:assert";

import { column, manyToMany } from "@adonisjs/lucid/orm";
import { ColumnOptions, LucidModel } from "@adonisjs/lucid/types/model";
import {
  ManyToMany,
  ManyToManyRelationContract,
  ManyToManyRelationOptions,
} from "@adonisjs/lucid/types/relations";

import { AutogenCacheEntry } from "#utils/model_autogen";
import "#validators/db";

type SharedColumnTypes = "string" | "number" | "boolean";
export type ColumnType = SharedColumnTypes | "enum" | "DateTime";
type DecoratorTypes = SharedColumnTypes | "integer" | "uuid";

interface ColumnDef extends ColumnOptions {
  meta?: {
    typing?: {
      declaredType?: ColumnType;
      allowedValues?: string[];
      validator?: SchemaTypes;
      optional?: boolean;
      autoGenerated?: boolean;
    };
  };
}

export interface ValidatedColumnDef extends ColumnOptions {
  meta: {
    typing: (
      | {
          declaredType: Exclude<ColumnType, "enum">;
          allowedValues?: undefined;
        }
      | {
          declaredType: "enum";
          allowedValues: string[];
        }
    ) & {
      validator: SchemaTypes;
      optional: boolean;
      autoGenerated: boolean;
    };
  };
}

const types = new Set(["number", "string", "boolean", "DateTime", "enum"]);

export function validateColumnDef(
  col: ColumnOptions,
): col is ValidatedColumnDef {
  // TS/eslint is really weird here about col.meta being defined as `any`
  const meta = col.meta as object | null | undefined;
  return (
    // col.meta
    meta !== null &&
    typeof meta === "object" &&
    // meta.typing
    "typing" in meta &&
    meta.typing !== null &&
    typeof meta.typing === "object" &&
    // meta.typing.declaredType
    "declaredType" in meta.typing &&
    typeof meta.typing.declaredType === "string" &&
    types.has(meta.typing.declaredType) &&
    // meta.typing.allowedValues if type == enum, otherwise require undefined
    ((meta.typing.declaredType !== "enum" &&
      (!("allowedValues" in meta.typing) ||
        meta.typing.allowedValues === undefined)) ||
      ("allowedValues" in meta.typing &&
        Array.isArray(meta.typing.allowedValues))) &&
    // meta.typing.validator
    "validator" in meta.typing &&
    typeof meta.typing.validator === "object" &&
    // meta.typing.optional
    "optional" in meta.typing &&
    typeof meta.typing.optional === "boolean" &&
    // meta.typing.autoGenerated
    "autoGenerated" in meta.typing &&
    typeof meta.typing.autoGenerated === "boolean"
  );
}

type SharedTypedColumnOptions = Partial<ColumnDef> & {
  /**
   * a raw vinejs "validator" (not vine.compile()d)
   */
  validator?: SchemaTypes;
  /**
   * false by default - if true, null/unefined values will be allowed in CRUD endpoints
   */
  optional?: boolean;
  /**
   * defaults to true if primaryKey or autoCreate = true, false otherwise
   * if true, this field will not be allowed in CRUD endpoints
   */
  autoGenerated?: boolean;
};

type MainTypedColumnOptions = SharedTypedColumnOptions &
  (
    | {
        type: DecoratorTypes;
        /**
         * a raw vinejs "validator" (not vine.compile()d)
         */
        validator?: SchemaTypes;
        foreignKeyOf?: undefined;
      }
    | {
        type: Record<string, string>; // enum
        /**
         * enums are not allowed to have custom validators
         */
        validator?: undefined;
        foreignKeyOf?: undefined;
      }
    | {
        /**
         * Lucid model whose primary key parameters should be copied
         *
         * this is a function to avoid issues with circular dependencies
         */
        foreignKeyOf: () => LucidModel;
        type?: undefined;
        validator?: undefined;
      }
  );

type DateTypedColumnOptions = SharedTypedColumnOptions & {
  // lucid column.date() options
  autoCreate?: boolean;
  autoUpdate?: boolean;
};

type RelationColumnDef = {
  validator: SchemaTypes;
  optional: boolean;
  autoGenerated: boolean;
  /**
   * Columns with this options set to true can be provided as additional filters to the detach endpoint
   */
  detachFilter: boolean;
} & (
  | { type: Exclude<ColumnType, "enum"> }
  | { type: "enum"; allowedValues: string[] }
);

type TypedManyToManyOptions<Related extends LucidModel> = Omit<
  ManyToManyRelationOptions<ManyToMany<Related>>,
  "pivotColumns"
> & {
  pivotColumns: Record<
    string,
    (
      | {
          type: DecoratorTypes;
          validator?: SchemaTypes;
        }
      | {
          type: Record<string, string>;
          validator?: undefined;
        }
    ) & {
      optional?: boolean;
      autoGenerated?: boolean;
      /**
       * Columns with this options set to true can be provided as additional filters to the detach endpoint
       */
      detachFilter?: boolean;
    }
  >;
  meta?: {
    declaredColumnTypes: Record<string, RelationColumnDef>;
  };
};

function decoratorTypeToValidatorAndType(
  type: DecoratorTypes | Record<string, string>,
  optional: boolean | undefined,
): { validator: SchemaTypes; declaredType: ColumnType } {
  if (typeof type === "string") {
    const declaredType =
      type === "integer" ? "number" : type === "uuid" ? "string" : type;
    let validator;
    switch (type) {
      case "string": {
        if (optional === true) {
          validator = vine.string().trim().minLength(1).nullable().optional();
        } else {
          validator = vine.string().trim().minLength(1);
        }
        break;
      }
      case "number": {
        if (optional === true) {
          validator = vine.number().nullable().optional();
        } else {
          validator = vine.number();
        }
        break;
      }
      case "boolean": {
        if (optional === true) {
          validator = vine.boolean().nullable().optional();
        } else {
          validator = vine.boolean();
        }
        break;
      }
      case "integer": {
        if (optional === true) {
          validator = vine.number().withoutDecimals().nullable().optional();
        } else {
          validator = vine.number().withoutDecimals();
        }
        break;
      }
      case "uuid": {
        if (optional === true) {
          validator = vine
            .string()
            .uuid({ version: [4] })
            .nullable()
            .optional();
        } else {
          validator = vine.string().uuid({ version: [4] });
        }
        break;
      }
    }
    return {
      declaredType,
      validator,
    };
  } else {
    let validator;
    if (optional === true) {
      validator = vine.enum(type).nullable().optional();
    } else {
      validator = vine.enum(type);
    }
    return {
      declaredType: "enum",
      validator,
    };
  }
}

type LazyTyping =
  | {
      booted: false;
      options: MainTypedColumnOptions;
      typing?: ValidatedColumnDef["meta"]["typing"];
    }
  | {
      booted: true;
      options?: MainTypedColumnOptions;
      typing: ValidatedColumnDef["meta"]["typing"];
    };

function computeTyping(
  options: MainTypedColumnOptions,
): ValidatedColumnDef["meta"]["typing"] {
  if (options.foreignKeyOf !== undefined) {
    const model = options.foreignKeyOf();
    const autogen = AutogenCacheEntry.for(model);
    const primaryKey = autogen.primaryKeyField.columnOptions;
    let validator = vine.foreignKey(model);
    if (
      options.optional === true &&
      "nullable" in validator &&
      typeof validator.nullable === "function"
    ) {
      validator = (validator.nullable as () => SchemaTypes)();
    }
    if (
      options.optional === true &&
      "optional" in validator &&
      typeof validator.optional === "function"
    ) {
      validator = (validator.optional as () => SchemaTypes)();
    }

    return {
      optional: options.optional ?? false,
      declaredType: primaryKey.meta.typing.declaredType,
      validator,
      autoGenerated: options.autoGenerated ?? options.isPrimary ?? false,
      allowedValues: primaryKey.meta.typing.allowedValues,
    } as ValidatedColumnDef["meta"]["typing"];
  } else {
    const { declaredType, validator } = decoratorTypeToValidatorAndType(
      options.type,
      options.optional,
    );
    return {
      optional: options.optional ?? false,
      declaredType,
      validator: options.validator ?? validator,
      autoGenerated: options.autoGenerated ?? options.isPrimary ?? false,
      allowedValues:
        typeof options.type === "object"
          ? Object.keys(options.type)
          : undefined,
    } as ValidatedColumnDef["meta"]["typing"];
  }
}

function initializeLazyTyping(
  target: LazyTyping,
): ValidatedColumnDef["meta"]["typing"] {
  if (!Reflect.get(target, "booted")) {
    const options = Reflect.get(target, "options");
    assert(options !== undefined);
    Reflect.set(target, "typing", computeTyping(options));
    Reflect.set(target, "booted", true);
  }
  const typing = Reflect.get(target, "typing");
  assert(typing !== undefined);
  return typing;
}

const lazyTypingHandlers: ProxyHandler<LazyTyping> = {
  set: () => false,
  deleteProperty: () => false,
  defineProperty: () => false,
  setPrototypeOf: () => false,
  preventExtensions: () => false,
  isExtensible: () => false,
  getPrototypeOf(target) {
    const typing = initializeLazyTyping(target);
    return Reflect.getPrototypeOf(typing);
  },
  getOwnPropertyDescriptor(target, p) {
    const typing = initializeLazyTyping(target);
    return Reflect.getOwnPropertyDescriptor(typing, p);
  },
  has(target, p) {
    const typing = initializeLazyTyping(target);
    return Reflect.has(typing, p);
  },
  get(target, p, receiver) {
    const typing = initializeLazyTyping(target);
    return Reflect.get(typing, p, receiver);
  },
  ownKeys(target) {
    const typing = initializeLazyTyping(target);
    return Reflect.ownKeys(typing);
  },
};

function createLazyTypingProxy(
  options: MainTypedColumnOptions,
): ValidatedColumnDef["meta"]["typing"] {
  return new Proxy<LazyTyping>(
    {
      booted: false,
      options,
    },
    lazyTypingHandlers,
    // proxy handlers are configured to lazily compute the typing field and redirect everything to it
  ) as unknown as ValidatedColumnDef["meta"]["typing"];
}

/**
 * Property decorator for injecting custom column types into a Lucid model.
 * ---------------------------------------------------------------------
 *
 * The `typedColumn` decorator allows you to specify and inject custom types for model columns by
 * adding type information to the `meta` property of each column definition.
 *
 * `typedColumn` is a replacement for lucid's `column` decorator.
 *
 * **Support for Enums**
 * - Enums are supported, provide an enum object as a value instead of string literal of a type
 * - such provided enum injects specified type and allowed values
 *
 */
export function typedColumn(options: MainTypedColumnOptions) {
  const finalOptions: Partial<MainTypedColumnOptions & ColumnDef> = {
    ...options,
  };
  finalOptions.meta ??= {};
  finalOptions.meta.typing = createLazyTypingProxy(options);
  delete finalOptions.type;
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  delete finalOptions.foreignKeyOf;
  return column(finalOptions);
}

function dateTypedColumn(
  options: DateTypedColumnOptions,
  variant: "dateTime" | "date",
) {
  options.meta ??= {};
  options.meta.typing = {};
  options.meta.typing.declaredType = "DateTime";
  options.meta.typing.optional = options.optional ?? false;
  if (options.validator !== undefined) {
    options.meta.typing.validator = options.validator;
  } else if (options.meta.typing.optional) {
    options.meta.typing.validator = vine.date().optional();
  } else {
    options.meta.typing.validator = vine.date();
  }
  options.meta.typing.autoGenerated =
    options.autoGenerated ??
    ((options.isPrimary ?? false) || (options.autoCreate ?? false));
  const finalOptions: Partial<DateTypedColumnOptions & ColumnDef> = {
    ...options,
  };
  delete finalOptions.validator;
  delete finalOptions.optional;
  delete finalOptions.autoGenerated;
  if (variant === "date") {
    return column.date(finalOptions);
  }
  return column.dateTime(finalOptions);
}

typedColumn.date = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "date");
typedColumn.dateTime = (options: DateTypedColumnOptions) =>
  dateTypedColumn(options, "dateTime");

export type TypedManyToManyContract<
  M1 extends LucidModel,
  M2 extends LucidModel,
> = ManyToManyRelationContract<M1, M2> & {
  options: {
    meta: {
      declaredColumnTypes: Record<string, RelationColumnDef>;
    };
  };
};

export function validateTypedManyToManyRelation<
  M1 extends LucidModel,
  M2 extends LucidModel,
>(
  relation: ManyToManyRelationContract<M1, M2>,
): relation is TypedManyToManyContract<M1, M2> {
  return (
    "options" in relation &&
    typeof relation.options === "object" &&
    relation.options !== null &&
    "meta" in relation.options &&
    typeof relation.options.meta === "object" &&
    relation.options.meta !== null &&
    "declaredColumnTypes" in relation.options.meta
  );
}

export function typedManyToMany<Related extends LucidModel>(
  model: () => Related,
  options: TypedManyToManyOptions<Related>,
) {
  options.meta ??= { declaredColumnTypes: {} };
  options.meta.declaredColumnTypes = Object.fromEntries(
    Object.entries(options.pivotColumns).map(([name, opts]) => {
      const { declaredType, validator } = decoratorTypeToValidatorAndType(
        opts.type,
        opts.optional,
      );
      if (declaredType === "enum") {
        assert(typeof opts.type === "object");
        return [
          name,
          {
            type: declaredType,
            allowedValues: Object.keys(opts.type),
            validator,
            optional: opts.optional ?? false,
            autoGenerated: opts.autoGenerated ?? false,
            detachFilter: opts.detachFilter ?? false,
          },
        ];
      }
      return [
        name,
        {
          type: declaredType,
          validator: opts.validator ?? validator,
          optional: opts.optional ?? false,
          autoGenerated: opts.autoGenerated ?? false,
          detachFilter: opts.detachFilter ?? false,
        },
      ];
    }),
  ) as Record<string, RelationColumnDef>;
  if (options.pivotTimestamps === true) {
    options.meta.declaredColumnTypes.createdAt = {
      type: "DateTime",
      validator: vine.date(),
      optional: false,
      autoGenerated: true,
      detachFilter: false,
    };
    options.meta.declaredColumnTypes.updatedAt = {
      type: "DateTime",
      validator: vine.date(),
      optional: false,
      autoGenerated: true,
      detachFilter: false,
    };
  }

  const col: ManyToManyRelationOptions<ManyToMany<Related>> = {
    ...options,
    pivotColumns: Object.keys(options.pivotColumns),
  };
  return manyToMany(model, col);
}
