import vine, { VineBoolean, VineObject, VineValidator } from "@vinejs/vine";
import { OptionalModifier } from "@vinejs/vine/schema/base/literal";
import { SchemaTypes } from "@vinejs/vine/types";

import { LucidModel, ModelColumnOptions } from "@adonisjs/lucid/types/model";

import {
  ValidatedColumnDef,
  validateColumnDef,
  validateTypedManyToManyRelation,
} from "#decorators/typed_model";
import { InvalidModelDefinition } from "#exceptions/model_autogen_errors";
import "#utils/maps";

export type RelationValidator = VineValidator<
  VineObject<
    Record<string, OptionalModifier<VineBoolean>>,
    Record<string, string | number | boolean | null | undefined>,
    Record<string, boolean | undefined>,
    Record<string, boolean | undefined>
  >,
  [undefined]
>;
export type AnyValidator = VineValidator<SchemaTypes, [undefined]>;

export interface PrimaryKeyFieldDescriptor {
  fieldName: string;
  columnOptions: ValidatedColumnDef;
}

export class AutogenCacheEntry {
  public readonly model: LucidModel;
  #primaryKeyField?: PrimaryKeyFieldDescriptor | InvalidModelDefinition;
  // i give up on properly typing these validators
  #pathIdValidator?: AnyValidator;
  #storeValidator?: AnyValidator;
  #updateValidator?: AnyValidator;
  // indexed by relation name
  #relationStoreValidators = new Map<string, AnyValidator>();
  #relationAttachValidators = new Map<string, AnyValidator>();
  #relationDetachValidators = new Map<string, AnyValidator>();
  #manyToManyIdValidators = new Map<string, AnyValidator>();

  private constructor(model: LucidModel) {
    this.model = model;
  }

  static for(model: LucidModel): AutogenCacheEntry {
    return modelAutogenCache.getOrInsertWith(
      model,
      (m) => new AutogenCacheEntry(m),
    );
  }

  private computePrimaryKeyField():
    | PrimaryKeyFieldDescriptor
    | InvalidModelDefinition {
    let primaryKeyField;
    for (const [name, field] of this.model.$columnsDefinitions.entries()) {
      if (!field.isPrimary) {
        continue;
      }
      if (primaryKeyField !== undefined) {
        primaryKeyField = new InvalidModelDefinition(
          `Model '${this.model.name}' has more than one primary key field!`,
        );
        break;
      }
      if (!validateColumnDef(field)) {
        primaryKeyField = new InvalidModelDefinition(
          `Model ${this.model.name}'s primary key field isn't properly typed!`,
        );
        break;
      }
      primaryKeyField = {
        fieldName: name,
        columnOptions: field as ValidatedColumnDef,
      };
    }

    primaryKeyField ??= new InvalidModelDefinition(
      `Model '${this.model.name}' has no primary key field!`,
    );
    return primaryKeyField;
  }

  public get primaryKeyField(): PrimaryKeyFieldDescriptor {
    this.#primaryKeyField ??= this.computePrimaryKeyField();

    if (this.#primaryKeyField instanceof InvalidModelDefinition) {
      throw this.#primaryKeyField;
    }
    return this.#primaryKeyField;
  }

  public get pathIdValidator(): AnyValidator {
    this.#pathIdValidator ??= vine.compile(
      vine.object({
        params: vine.object({
          id: this.primaryKeyField.columnOptions.meta.typing.validator,
        }),
      }),
    );

    return this.#pathIdValidator;
  }

  public get storeValidator(): AnyValidator {
    this.#storeValidator ??= vine.compile(
      vine.object(
        Object.fromEntries(
          this.model.$columnsDefinitions
            .entries()
            .map((value: [string, ModelColumnOptions]) => {
              const [name, field] = value as [string, ValidatedColumnDef];
              if (field.meta.typing.autoGenerated) {
                return undefined;
              }
              return [name, field.meta.typing.validator] as [
                string,
                SchemaTypes,
              ];
            })
            .filter((e) => e !== undefined),
        ),
      ),
    );

    return this.#storeValidator;
  }

  public get updateValidator(): AnyValidator {
    this.#updateValidator ??= vine.compile(
      vine.object(
        Object.fromEntries(
          this.model.$columnsDefinitions
            .entries()
            .map((value: [string, ModelColumnOptions]) => {
              const [name, field] = value as [string, ValidatedColumnDef];
              if (field.meta.typing.autoGenerated) {
                return undefined;
              }
              let validator = field.meta.typing.validator;
              if (
                "optional" in validator &&
                typeof validator.optional === "function"
              ) {
                validator = (validator.optional as () => SchemaTypes)();
              }
              return [name, validator] as [string, SchemaTypes];
            })
            .filter((e) => e !== undefined),
        ),
      ),
    );

    return this.#updateValidator;
  }

  public relatedStoreValidator(relationName: string): AnyValidator {
    return this.#relationStoreValidators.getOrInsertWith(relationName, () => {
      const relation = this.model.$relationsDefinitions.get(relationName);
      if (relation === undefined) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' does not exist on model '${this.model.name}'`,
        );
      }
      if (!relation.booted) {
        relation.boot();
      }
      const foreignKey =
        relation.type === "hasMany" ? relation.foreignKey : undefined;
      return vine.compile(
        vine.object(
          Object.fromEntries(
            relation
              .relatedModel()
              .$columnsDefinitions.entries()
              .map((value: [string, ModelColumnOptions]) => {
                const [name, field] = value as [string, ValidatedColumnDef];
                if (field.meta.typing.autoGenerated || name === foreignKey) {
                  return undefined;
                }
                return [name, field.meta.typing.validator] as [
                  string,
                  SchemaTypes,
                ];
              })
              .filter((e) => e !== undefined),
          ),
        ),
      );
    });
  }

  public attachValidator(relationName: string): AnyValidator {
    return this.#relationAttachValidators.getOrInsertWith(relationName, () => {
      const relation = this.model.$relationsDefinitions.get(relationName);
      if (relation === undefined) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' does not exist on model '${this.model.name}'`,
        );
      }
      if (relation.type !== "manyToMany") {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' is not a manyToMany relation!`,
        );
      }
      if (!validateTypedManyToManyRelation(relation)) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' isn't properly typed!`,
        );
      }
      if (!relation.booted) {
        relation.boot();
      }
      return vine.compile(
        vine.object(
          Object.fromEntries(
            Object.entries(relation.options.meta.declaredColumnTypes)
              .map(([name, field]) => {
                if (field.autoGenerated) {
                  return undefined;
                }
                return [name, field.validator];
              })
              .filter((e) => e !== undefined),
          ),
        ),
      );
    });
  }

  public detachValidator(relationName: string): AnyValidator {
    return this.#relationDetachValidators.getOrInsertWith(relationName, () => {
      const relation = this.model.$relationsDefinitions.get(relationName);
      if (relation === undefined) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' does not exist on model '${this.model.name}'`,
        );
      }
      if (relation.type !== "manyToMany") {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' is not a manyToMany relation!`,
        );
      }
      if (!validateTypedManyToManyRelation(relation)) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' isn't properly typed!`,
        );
      }
      if (!relation.booted) {
        relation.boot();
      }
      return vine.compile(
        vine.object(
          Object.fromEntries(
            Object.entries(relation.options.meta.declaredColumnTypes)
              .map(([name, field]) => {
                if (!field.detachFilter) {
                  return undefined;
                }
                let validator = field.validator;
                if (
                  "optional" in validator &&
                  typeof validator.optional === "function"
                ) {
                  validator = (validator.optional as () => SchemaTypes)();
                }
                return [name, validator];
              })
              .filter((e) => e !== undefined),
          ),
        ),
      );
    });
  }

  public manyToManyIdsValidator(relationName: string): AnyValidator {
    return this.#manyToManyIdValidators.getOrInsertWith(relationName, () => {
      const relation = this.model.$relationsDefinitions.get(relationName);
      if (relation === undefined) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' does not exist on model '${this.model.name}'`,
        );
      }
      if (relation.type !== "manyToMany") {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' is not a manyToMany relation!`,
        );
      }
      if (!validateTypedManyToManyRelation(relation)) {
        throw new InvalidModelDefinition(
          `Relation '${relationName}' isn't properly typed!`,
        );
      }
      if (!relation.booted) {
        relation.boot();
      }
      const relatedField = relation
        .relatedModel()
        .$columnsDefinitions.get(relation.relatedKey);
      if (relatedField === undefined) {
        throw new InvalidModelDefinition(
          `Related key in relation '${relationName}' ('${relation.relatedKey}') doesn't exist on the related model!`,
        );
      }
      if (!validateColumnDef(relatedField)) {
        throw new InvalidModelDefinition(
          `Related key in relation '${relationName}' ('${relation.relatedKey}') isn't properly typed!`,
        );
      }
      return vine.compile(
        vine.object({
          params: vine.object({
            localId: this.primaryKeyField.columnOptions.meta.typing.validator,
            relatedId: (relatedField as ValidatedColumnDef).meta.typing
              .validator,
          }),
        }),
      );
    });
  }
}

const relationValidatorCache = new Map<string, RelationValidator>();
const modelAutogenCache = new Map<LucidModel, AutogenCacheEntry>();

export function relationValidator(relations: string[]): RelationValidator {
  return relationValidatorCache.getOrInsertWith(JSON.stringify(relations), () =>
    vine.compile(
      vine.object(
        Object.fromEntries(
          relations.map((rel) => [rel, vine.boolean().optional()]),
        ),
      ),
    ),
  );
}
